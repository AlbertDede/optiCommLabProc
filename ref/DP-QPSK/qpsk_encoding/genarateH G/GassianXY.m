function [outputH,outputG]=GassianXY(inputx,inputy);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%---- 该程序的目的：输入校验矩阵x，在二元域上对x进行高斯消去生成H，然后产生与H对应的生成矩阵G，输出H，G ----%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%----参考依据：x (高斯消去) -> H=[I|P] -> G=[P'|I]G ------%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%-----------第一步: 初始化相关数据 ---------------%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
H = inputx;
flag = inputy;%标志位，确定最后生成的G是右边为单位阵(flag = 1),还是左边为单位阵(flag = else)
H1 = H;
[m,n] = size(H);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%------------------第二步：高斯消去----------------%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%----    逐一检查H的每行,H(i,:),其中i=1:m,若H(i,i)==0,则   ----%%%%
%%%----寻找该行中第一个非零元,记录该非零元的列,并将H的该列与   ----%%%%
%%%----H的第i列交换;若H(i,i)==1,则不需要列交换.然后检查交换后 ----%%%%
%%%----或者不需要交换的H(:,i),自H(i,i)元素以下的第i+1行到m行 ----%%%%
%%%----是否还有非零元,有,则将H的第i行叠加到该行,无,则检查H的  ----%%%%
%%%----下一行,循环.结果是将H转化为一个左下方为全0,H(i,i)全1的 ----%%%%
%%%----矩阵,记为Hmid,再对Hmid自第m行向第j行叠加,j=m-1:-1:1, -----%%%%
%%%----循环之后得到左半为单位阵的矩阵[I|P]                  -----%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for i=1:m; % 逐一检查H的每行，H(i,:)
   if H1(i,i)==0;% 若H(i,i)==0的分支
      j=min(find(H1(i,:)));% 寻找该行中第一个非零元，记录该非零元的列
      H1(:,[i j])=H1(:,[j,i]);% 将H的该列与H的第i列交换，H矩阵作为保留输出的矩阵，H1用于运算
      H(:,[i j])=H(:,[j,i]);
      for k=i+1:m;% 自H(i,i)元素以下的第i+1行到m行是否还有非零元
          if H1(k,i)==1;% 有，则将H的第i行叠加到该行
             H1(k,:)=H1(i,:)+H1(k,:);
             H1(k,:)=mod(H1(k,:),2);
          end;% 无,则检查H的下一行
      end;
   else;% 若H(i,i)==1的分支，不需要交换行，只需要检查H(i,i)元素以下的第i+1行到m行是否还有非零元
      for k=i+1:m;
          if H1(k,i)==1;% 有，则将H的第i行叠加到该行
             H1(k,:)=H1(i,:)+H1(k,:);
             H1(k,:)=mod(H1(k,:),2);
          end;
      end;
   end;% 无,则检查H的下一行
end;

for i=m:-1:2;% 自第m行向第j行叠加,j=m-1:-1:1
  for k=i-1:-1:1;
    if H1(k,i)==1;
       H1(k,:)=H1(i,:)+H1(k,:);
       H1(k,:)=mod(H1(k,:),2);
    end;
  end;% 循环之后得到左半为单位阵的矩阵H1 = [I|P]及H1对应的H
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%-----------------第三步：得到矩阵G----------------%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if flag ==1;% G的右边是单位阵
   PP = H1(:,m+1:n);% 取出H1的第m+1到n列
   G = [PP.' diag(ones(1,n-m))];%  H1=[I|P] -> G=[P'|I]
   outputH = H;
   outputG = G;% 可见解码时应该取x_hat的后n-m个数据才能得到原始数据
else;% G的左边为单位阵
   PP = H1(:,m+1:n);
   GT = [diag(ones(1,n-m));PP];
   outputH = [H(:,m+1:n) H(:,1:m)];
   outputG = GT.';
end;